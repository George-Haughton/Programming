# Programming mapping documents

## 1. Algorithm
An Algorithm is a formula that solves a problem, based on completing/conducting a sequence of outlined actions. Firstly, there are 5 important stages of building an App. The first stage is the Pre-production stage, where you will brainstorm and document every aspect of how your app works. The ideas you will brainstorm will consist of what is your expected users, what experience you would like your users to have and what the overall outcomes you expect from the user using the app. Secondly we have stage 2 which is about ‘telling your story’, after we have a basic idea of what we want the app to consist of we now need to make a low-fidelity storyboard detailing scene by scene of the app. This stage will not look aesthetically good, but it will outline the key points of the app, such as the flow of it, how it works, the logic behind the app and will give you a good idea of what the app actually is. This stage is very important and should not be rushed as it is the base foundations of your app and should be looked at it high detail, involving as many people as you can. Thirdly, the visual design stage. This is where you will create the look and feel of your app. For example, creating the UI (user interface) elements (how the user will navigate their way around your app), the transitions between scenes, the design of each page (how the text it positioned, what colours are you going to use and what images) and finally what interactive component are going to be used on each page, but we do not make any code all we are doing is building an idea of how the app works and how it’s going to look. The fourth stage is the coding/programming of the app which is arguably the most important stage, when coding an app, you will need to choose a preferred platform you would like the app to start on then after you have perfected the first platform you can move onto others. This is a good way of keeping the job easy for yourself as trying to get an app up and running on both platforms at the same time can be a difficult task. During this process you will be constantly adjusting the code to make sure no bugs develop and to make sure the code works completely without any mishaps. With this stage it can take longer than intended because of the bugs and things of this nature stopping the app from progressing. Finally, we have the launch stage where we will have to speak to companies about putting the app on their platforms and prices and things of this nature. As with any app the general public might find bugs and problems with the app you and your company did not consider or find, and this is where the continuous running of the app, and continuous updates will need to keep happening to make sure the app is always at a standard the users are happy with and they are not any problems that stop the users using the app in its intended way.

## 2 Paradigms 

### 2.1 Procedural
Procedural language uses programming languages like Pascal, C++, Fortran and C; these are very detailed and will take up alot of time when writing them. Procedural language is a list of instructions that tell the computer exactly what to do. This language will make sure the computer knows step-by-step exactly what to do and how to perform each line of code until the code is finished. It relies on the programmer to do a lot of the work and the programmer will need to provide a solution to a problem or to proivde an answer to a question. It keeps the code as short as possible and somewhere in the code it will contain a sequence of steps that it needs to carry out. Additionally, it does not allow the programmer to copy and paste the code onto another program. Lastly, it can be very difficult to learn because it can take time getting used to.

### 2.2 Object Orientated
Object Orientated programming is a language model based around objects instead of 'actions' and instead of logic it uses data. Additioanlly, instead of writing an algorithm it breaks down the problem of elements into classes. It uses objects that consist of data fields and methods to create applications and computer programs. A few examples of common programming laguages that use some techniques from the Object orientated language, are Java, Microsoft Visual Basic .NET, Microsoft C# and C++. Finally, the programmers are able to edit the code without any errors appearing and unlike the Procedural language the programmer can copy and paste the code into other problems if they need to.

### 2.3  Event Driven
This type of paradigm is determined by events or user actions for example mouse clicks, or keyboard presses. It can only be used alongside using a graphical user interface which is one of its main features. This program is not complex and does not need a huge amount of experience to use correctly. When making a program certain languages will only allow the programmer/user to save every property of the program one after the other; whereas with Event Driven programming the programmer can easily develop a program and save all of the properties at the same time saving a huge amount of time and effort.

The similarities/relationship between Event Driven and Procedural. Both are methods of structured programming where the code is split into routines and functions. Both are able to take input from the user or from within the program and make calls to the various functions within the program based on the information it recieves. Additionally, early versions of the Object orientated Programming included Event Driven systems such as simulations and graphical user interfaces.

## Debugging
Debugging is the process of finding and removing existing and potential errors also referred to as 'bugs'. Debugging is used to get rid of these 'bugs' in software code that could cause the system to act incorrectly, crash, or not work at all. Additionally, when various subsystems or modules are tightly packed it makes debugging a lot harder as when one bug ix fixed it can cause another bug to occur. In some occasions it takes more time to debug a program than it does to code it. The debugging process can be a time consuming job but it has to be done. The first step of the debugging process is to Reproduce the bug/problem, it is very important you reproduce the bug to make sure you know what you're dealing with, if you cant reproduce the bug get someone else to. Secondly, describe the bug, try to get as much information/input from the user to get the exact reason. Thirdly, capture a program snapshot when the bug appears, to get to as much information on the bug, all the variable values and the state of the program at the time of the bug occuring. Fourthly, take a look at the screenshot in depth, does anything look out of place or different? Analyse the screenshot based on the state and action. Based on all this try to find the causes of the bug.Finally, the most important phase, fix the bug. Erase the bug as best you can to make sure your program runs as smoothly as possible, but make sure when fixing this bug it does not create another, somewhere else in the code.

Within an IDE there is something called a debugger. You can use a debugger outside of an IDE but the ones within an IDE are completely integrated with the other workbench tools, this gives the user the flexibility they need to adress the problems at hand. A debugger is essential to ensuring there is no way the bug will survive. There are other softwares that can be used but none of them give the user the power like a debugger does. Firstly, one feature within the debugger that is very useful is the fact that it can display complete data structuresm full runtime stacks and multi-threaded environments easily and in a more readable way. The debugger offers several ways to reduce the time, and the repetitive work that comes with debugging. Additionally, a visual debugger integrated into an IDE gives the user access to smart editing and all of the other features of the IDE, in an 'Integrated Development Environment' which is also what IDE stands for, hence the name. Finally, unlike manual debuggers, debuggers within an IDE can attach to a running process or a crash dump; whereass in a manual debugger 'steps to reproduce' a defect are necessary.


























